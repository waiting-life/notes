## 问题

+ node事件循环



+ node中有哪些全局变量



+ koa和express



+ POST提交数据的几种方式





+ `[] == ![]`和`[] == []`的值

**== 是如何工作的**

1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，`false——>0,true——>1`
2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值。
3. 如果一个操作数是对象，另一个操作数不是，则调用对象的`valueOf()`方法，如果得到的值不是基本类型值，则给予返回值再调用`toString`方法用得到的基本类型值按照前面的规则进行比较。
4. 如果两个操作数都是对象，则比较他们是不是同一个对象，如果两个操作数指向同一个对象，则相等返回true，否则返回false

```js
[] == []  // false
null == undefined //  true
null === undefined // false

NaN == NaN  // false
NaN != NaN  // true
```

这两个操作符在进行比较时则要遵循下列规则。

1. null 和 undefined 是相等的。
2. 要比较相等性之前，不能将null和undefined转换成其他任何值
3. 如果有一个操作数是NaN，则相等操作符返回false, 而不相等操作符则返回true, NaN != NaN

`[] == ![]`

1. !运算符的优先级大于 `==`， ！会将后面的值转化为布尔值即`![] 变成 !Boolean([])`，也就是`!true`，也就是false. 

2. 实际上是对比`[] == false`

运算上面的顺序，false是布尔值，所以转化为数值`Number(false)`为0.

3. 对比`[] == 0`

满足第三条规则，[]是对象（数组也属于对象），0不是对象。所以`ToPrimitive`([])是`""`

4. 对比`"" == 0`

满足第二条规则，`""`是字符串，0是数值，对比`Number(0) == 0`，也就是 `0 == 0`

所以得出`[] == ![]`

```js
var a = 0, b = 0
function A(a) {
    // 没有定义的变量为全局变量
    // 第一次执行的时候，给函数A赋值了新的函数
    // a++ 先返回a，然后再a = a + 1
    
    // 第二次调用函数A的时候，此时函数已经是赋值后的函数
    // 执行这个函数
    A = function (b) {
        console.log(a + b++)
    }
    console.log(a++)
}
A(1)
A(2)
// 1
// 4


a = 0; b = 0; A = fn1
A(1)
a = 0; b = 0; A = fn2 // g
a = 2 // fn1 
A(2) 




var result = [];
var a = 3;
var total = 0;
function foo(a) {
  for (var i = 0; i < 3; i++) {
    result[i] = function() {
      total += i * a;
      console.log(total);
    }
  }
}

foo(1);
result[0]();
result[1]();
result[2]();


// 3
// 6
// 9

let result = []
function A() {
    for(var i = 0; i < 3; i++) {
        console.log(i)
        result[i] = function() {
            console.log(i)
        }
    }
}


// 事件循环
async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(() => {
  console.log('setTimeout')
}, 0);
async1()
new Promise(resolve => {
    console.log('promise1')
    resolve()
  })
  .then(() => {
    console.log('promise2')
  })
console.log('script end')

script start 
async1 start 
async2
// 执行完async2()之后，会将await async2()后面的代码放入对应的微队列中 
promise1
// 调用了resolve()，promise状态变为resolved，然后将then里面的任务放到微任务队列中
script end 
// 执行完宏任务后，执行微任务队列中的所有微任务
async1 end
promise2
setTimeout


async function async1() {
  console.log('async1 start')
  await async2()
  console.log('async1 end')
}
async function async2() {
  new Promise(resolve => {
      console.log('promise1')
      resolve()
    })
    .then(() => {
      console.log('promise2')
    })
}
console.log('script start')
setTimeout(() => {
  console.log('setTimeout')
}, 0);
async1()
new Promise(resolve => {
    console.log('promise3')
    resolve()
  })
  .then(() => {
    console.log('promise4')
  })
console.log('script end')
// script start
// async1 start
// promise1
// promise3
// script end
// promise2
// async1 end
// promise4
// setTimeout


async function async1() {
  console.log('async1 start')
  await async2()
  setTimeout(() => {
    console.log('setTimeout1')
  }, 0)
}
async function async2() {
  setTimeout(() => {
    console.log('setTimeout2')
  }, 0)
}
console.log('script start')
setTimeout(() => {
  console.log('setTimeout3')
}, 0);
async1()
new Promise(resolve => {
    console.log('promise1')
    resolve()
  })
  .then(() => {
    console.log('promise2')
  })
console.log('script end')


script start
// async1 start
// promise1
// script end
// promise2
// setTimeout3
// setTimeout2
// setTimeout1
```



### html

+ html里head可以放哪些标签
+ html里有target属性的都有哪些元素
+ h5里面有哪些新增的api
+ input的类型
+ 

### css

+ rem和em的区别
+ 如何画一个三角形
+ css垂直水平居中

水平居中：行内元素行内块元素，text-align:center

块级元素：margin: 0 auto

垂直水平居中：

绝对定位

+ css实现九宫格

+ 如何消除三个33%之后页面最下方的白线

+ css里有哪些动画

+ css的动画为什么比js性能好

+ css样式权重

+ 伪类、伪元素，为什么要用

+ flex盒子，css盒模型

+ bfc

+ 后代选择器：

  可以选择父元素里面所有的子元素 ul li {}
  
+ 子元素选择器
  子元素选择器只能作为某元素的最近一级子元素，简单理解就是亲儿子元素

```css
background-image: url(images/logo.png);
background-repeat: no-repeat;
background-position: left top;
background: rgba(0,0,0,0.3);
```



层叠性：样式冲突，下面的覆盖上面的

继承性：如文本颜色和字体大小。test-,font-,line-,以及color

优先级：

如果盒子没有指定width/height属性，则此时padding不会撑开盒子大小。



块级盒子水平居中：

1. 必须有宽度，盒子左右的margin设置为auto

```css
margin: 0 auto;
```

行内元素行内块元素水平居中：

行内元素或者行内块元素给其父元素添加text-align:center;



**嵌套块元素垂直外边距塌陷的问题：**

对于两个嵌套的（父子关系）块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。

解决方案：

+ 可以为父元素定义上边框
+ 可以为父元素定义上内边距
+ 可以为父元素添加overflow-hidden
+ 如果盒子有浮动、固定、绝对定位的盒子不会有塌陷问题。

行内元素尽量只设置左右的内外边距。

浮动元素会具有行内块元素的特性。



注意：**为什么清除浮动**

父元素没有指定高度，子元素浮动不占有位置，父元素高度就会为0，下面的标准流的盒子就会上去。

清除浮动：

**闭合浮动：**

```js
选择器 clear: both;
```

1. 额外标签法：在最后一个元素后面添加一个新的标签。.clear { clear: both},这个新增的元素必须是块级元素。
2. 父级添加overflow属性
3. 父级添加after伪元素：

```css
.clearfix:after {
    content: "";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}
.clearfix {
    *zoom： 1；
}
```



4. 父级添加双伪元素

```css
.clearfix:before .clearfix:after {
    content: "";
    display: table;
}
.clearfix:after {
    clear: both;
}
.clearfix {
    *zoom： 1；
}
```

只有定位的盒子才有z-index属性。

行内元素添加浮动或者加了固定、绝对定位，可以直接设置高度和宽度

块级元素添加绝对定位或者固定定位，如果不给宽度或高度，默认大小是内容的大小。

visibility隐藏元素后，继续占有原来的位置。

+ css三角的做法

```css
.box {
    width: 0;
    height: 0;
    line-height: 0;		// 为了兼容性
    font-size: 0;
    border: 10px solid transparent;
    border-top-color: pink;
}
```



```css
/* 单行溢出文字，不允许换行,文字溢出用省略号 **/
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;


/*多行文本溢出显示省略号**/

```



nth-child先看是第几个孩子，再看前面的元素。

nth-of-type: 先看前面的元素，再看第几个孩子

### js

+ 0.1 + 0.2 等于 0.3 吗？为什么？解决方案？
+ js如何监听一个数的变化，不是dom的监听方式
+ JS实现一个JSON.stringify()功能的函数
+ Https和http的区别是什么，https的握手过程详细说
+ JS基本数据类型，symbol的使用场景
+ JS遍历数组有哪些方法，说的全面一点
+ for in和for of有什么不同，for in可以访问到原型链上的数据吗？可以用于访问继承？
+ 闭包和立刻执行函数有什么区别
  + 调用的时候创建作用域，调用完后会销毁。
+ 闭包会造成内存泄漏吗？一定吗？为什么
  + 不会
+ hasOwnProperty会忽略原型链上继承到的属性。如果指定的属性在指定的对象或其原型链中，则**`in` 运算符**返回`true`。
+ 手写bind、apply、bind（this指向谁）、map、

```js
Function.prototype._bind = function(thisArg, ...argArray) {
    return (...newArgArray) => {
        return this.call(thisArg, ...argArray, ...newArgArray)
    }
}


Function.prototype._call = function(thisArg, ...args) {
    context = thisArg || window
    context.fn = this
    let result = context.fn(...args)
    delete context.fn
    return result
}

Function.prototype_apply =  function(thisArg, args) {
    context = thisArg || window
    context.fn = this
    let result = context.fn(...args)
    return result
}


Array.prototype._map = function(fn, thisArg) {
    if(fn.constructor !== Function) {
        throw new Error(fn +'is not a function')
    }
        
    let newArray = []
    for(let i = 0; i < this.length; i++) {
        newArray.push(fn.call(thisArg, this[i], i, this))
    }
    return newArray
}

Array.prototype._forEach = function(fn, thisArg) {
    if(fn.constructor !== Function) {
        throw new Error(fn +'is not a function')
    }
    for(let i = 0; i < this.length; i++) {
        fn.call(thisArg, this[i], i, this)
    }
}

Array.prototype._filter = function(fn, thisArg) {
    if(fn.constructor !== Function) {
        throw new Error(fn +'is not a function')
    }
    let newArray = []
    for(let i = 0; i < this.length; i++) {
        if(fn.call(thisArg, this[i], i, this)) {
            newArray.push(this[i])
        }
    }
    return newArray
}

Array.prototype._find = function(fn, thisArg) {
    if(fn.constructor !== Function) {
        throw new Error(fn +'is not a function')
    }
    for(let i = 0; i < this.length; i++) {
        if(fn.call(thisArg, this[i], i, this)) {
            return this[i]
        }
    }
}

function myNew(Fn, ...args) {
    let obj = object.create(Fn.prototype)
    let result = Fn.call(obj, ...args)
    return result instanceof Object ? result : obj
}

function myInstanceof (L, R) {
    const LProto = object.getPrototype
}

function myInstanceof(L, R) {
    if(typeof L !== 'object' || L === null) return false
    let LProto = Object.getPrototypeOf(L)
    let RProto = R.prototype
    while(true) {
        if(LProto === null) return false
        if(LProto === RProto) return true
        LProto = Object.getPrototypeOf(LProto)
    }
}
const arr = [1]
myInstanceof(arr, Array)	// true
myInstanceof(arr, Object)	// true
```

任务

- 实现p.catch，Promise.all，Promise.race。
- 



+ es6
+ **http状态码** 



1. 404的含义就是客户端所访问的资源不存在
2. 304 缓存
3. 301永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
4. 302临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
5. 200 得到响应
6. 500服务器内部错误，无法完成请求

+ promise如何实现比promise.all次一级的函数，也就是说不用等数组里面所有的promise实现完，只需要实现其中两个就返回true

  

+ promise.then()与promise.then().then()的区别

+ 闭包例题

+ 闭包的使用场景

+ **事件循环**

一个宏任务——>所有微任务——>宏任务——>所有微任务

+ 前端路由实现
+ 图片懒加载实现
+ **js原型链**

1. 比如我们声明一个`Animal`构造函数
2. 就会生成一个`Animal.prototype`的原型对象
3. 通过`new Animal`生成一个Animal的实例，此时该实例的`__proto__`属性指向`Animal.prototype`
4. `Animal.prototype`又指向`Onject.prototype` 

+ 鼠标拖动方块的动画帧触发了哪些事件
+ 数组乱序的方法
+ **new操作符都做了什么**

1. 首先会创建一个空的对象，空对象的`__proto__`属性指向构造函数的原型

```js
const obj = {}
```

2. 让构造函数内部的this指向我们创建的空对象obj
3. 如果构造函数返回一个非基本类型的值a，则返回这个值a，否则返回上面创建的对象obj

+ 你是怎么理解js作用域的
+ 假如js里面没有除法，你怎么实现
+ 写一个函数，输入2的时候返回3，输入3的时候返回2
+ 解析url得到参数
+ promise，都知道哪些事件队列
+ **this的改变知道哪几种**

1. apply(参数是数组)
2. call
3. bind

+ Object.prototype.__proto__返回什么？

null

+ **js如何实现继承**

1. es5



2. es6

+ 如何实现一定时间内用户登录状态保存
+ **localstorage、sessionstorage**

LocalStorage:

**持久化的本地存储，除非主动删除，否则数据不会过期**

SessionStorage

**会话结束（关闭页面）后，数据清除**

+ **cookie与session的区别**

浏览器发送HTTP请求时，先检查是否有相应的Cookie，如果有则将Cookie放在请求头中的Cookie字段中发送。

**注意**：每一次的HTTP请求时，如果有cookie，浏览器都会**自动**带上cookie发送给服务端。身份认证信息特别适合放在cookie中。

1. cookie是以小的文本文件形式（即纯文本），完全存在于客户端；cookie保存了**登陆的凭证**，有了它，只需要在下一次请求时带着cookie，就不必再重新输入用户名、密码等重新登陆了。
2. 是设计用来在**服务端**和**客户端**进行**信息传递**的。

1. **expires**：设置Cookie的过期时间。
2. **secure**：当secure设置为true的时候，只能用https，secure选项用来设置cookie只在确保安全的请求中方才会发送。

3. **httpOnly**：设置浏览器能否读取Cookie

当cookie带httpOnly选项时，客户端无法通过js代码去访问（包括**读取、修改、删除**等）这个cookie

在客户端是不能通过js去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。

**cookie的设置、读取、删除方法**：

**cookie既可以由服务端来设置，也可以由客户端来设置。**

+ 服务端设置cookie

通过在服务端设置`set-cookie`，每段对应一个cookie，注意每个cookie放一个`set-cookie`字段中，不能将多个cookie放在一个`set-cookie`字段中。具体每个cookie字段设置了相关的属性：expires、path、httpOnly

服务端可以设置cookie的所有选项：expires、domain、path、secure、HttpOnly

+ 客户端设置cookie

需要自己封装设置

封装cookie

```js
const cookieUtil = {
    setItem(name, value, days) {
        let date = new Date()
        date.setDate(date.getDate() + days)
        document.cookie = `${name}=${value};expires=${date}`
    },

    getItem(name) {
        let arr = document.cookie.split(';')
        let ret 
        arr.forEach(item => {
            let tempArr = item.trim().split('=')
            if (tempArr[0] === name) {
                ret = tempArr[1]
            }
        })
        return ret
    },

    removeItem(name) {
        this.setItem(name, null, -1)
    }
}

cookieUtil.setItem('name', 'cpp', 1)
cookieUtil.getItem('name')
cookieUtil.removeItem('name')
```



4. domain和path：限制Cookie能被哪些URL访问

domain是域名，path是路径，两者加起来就构成了url，domain和path一起来限制cookie能被哪些URL访问。

1. SameSite

```js
// document.cookie只能获取非HttpOnly类型的cookie
document.cookie

// 每个cookie都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过cookie选项来设置的。cookie选项包括：expires、domain、path、secure、HttpOnly。

```



**Cookie和Storage的对比**

1. Cookie存放数据小，4kb左右；而Storage可以存放5mb左右
2. Cookie可以设置国旗时间，SessionStorage会在会话关闭时清除，LocalStorage必须要手动清除。
3. Cookie参与和服务器的通信，Storage则一般不用于。



**Cookie和session的区别**

**session**

由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.

+ session是保存在服务端的，有一个唯一标识

+ 服务端如何识别特定的客户？这个时候cookie就登场了。

**cookie是存在客户端浏览器上，session会话存在服务器上。**

1. 通常使用Cookie时，会话数据都存在Cookie中。
2. 使用Session时，Cookie中只存放一个Session_id。
3. 会话数据放在服务端的内存或数据库中。

**JWT**

Session的一个缺点就是由于会话数据保存再服务端，所以在使用服务器集群的时候处理起来很麻烦。而使用JWT的话，会话数据都保存在客户端，就没有这种问题了。

JWT是个很长的字符串，中间用两个`.`分割为三个部分：Header(头部)、Payload(负载)、Signature(签名)

**CSRF**



**cors，跨域**



+ Websocket怎么建立的,和HTTP的关系
+ Websocket有没有同源限制？
+ setTimeout(0)和promise.then()区别
+ 实时协作编辑使用什么协议？
+ Babel转译原理
+ 讲解CSRF
+ csrf:跨站请求伪造
  + 用户不知情： 验证码
  + 跨站请求： referer验证
  + 参数伪造： token
+ **get post区别**



+ **post常用的content-type**
  + `Content-Type: application/json` "{name: 'wqj', age: 20}"
  + `Content-Type: multipart/form-data`,multipart/form-data 常被用于发送二进制文件,如图片/视频等内容.
  + ``Content-type: application/x-www-form-urlencoded`,<form>表单默认的数据提交格式。name=wqj&age=20
  + `Content-type: text/plain`,当传递对象/基本类型作为发送数据的参数，且没有手动设置`Content-type`时，浏览器会自动将`Content-type`设置为`text/plain`
+ JS怎么定义一个常量对象，内部属性无法修改

```js
Object.freeze()


var lg = {}
Object.defineProperty(lg, "name", {
    value: 'cpp',
    writable: false,
    confirurable: false
})
{name: "cpp"}
lg.name	// "cpp"
lg.name = 'cjz'	// "cjz"
lg.name	 // "cpp"
```

+ **如何阻止事件冒泡，如何阻止默认行为**

js冒泡和捕获是事件的两种行为，使用`event.stopPropagation()`起到阻止捕获和冒泡阶段中当前事件的进一步传播

使用`event.preventDefault()`可以取消默认事件。

```js
// 谷歌及IE8以上
e.preventDefault()
// IE8以下
window.event.returnValue = false
// 五兼容问题（但不能直接用于节点直接onClick绑定函数）
return false
```



+ 事件循环顺序
+ **实现一下把原生ajax封装成promise**

```js
const PromiseAjax = ({
    method = 'get',
    url = '/',
    data,
    async = true
}) => {
    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest()
        xhr.onreadystatechange = () => {
            if(xhr.readyState === 4 && xhr.status === 200) {
                let res = JSON.parse(xhr.responseText)
                resolve(res)
            }
        }
        xhr.open(method, url, async)
        if(method === 'get') {
            xhr.send()
        }
        if(method === 'post') {
            let type = typeof data
            let header
            if(type === 'string') {
                header = 'application/x-www-form-urlencode'
            } else {
                header = 'application/json'
                data = JSON.stringify(data)
            }
            xhr.setRequestHeader('Content-type', header)
        }
    })
}
Ajax.get = (url) => {
    return Ajax({
        url
    })
}
```



+ promise的原理

+ **事件传播**

```html
<body>
    <div class="outer">
        <div class="inner"></div>
    </div>
</body>
```

**点击事件传播途径**

1. body -> outer -> inner 这个过程从外往里，所以叫做**事件捕获**。
2. inner -> outer -> body  这个过程从里往外，所以叫做**事件冒泡**

**总结**：点击一个元素后，点击事件从外层元素开始向内传播(**称为事件捕获**)，直到我们的被点击元素(`e.target`)，之后从被点击元素开始向外传播(**称为事件冒泡**)

可以使用**event.stopPropagation**来阻止事件的传播。

+ **实现事件委托**

事件代理是由`event.target`实现的

```js
let ul = document.querySelector('ul')
ul.addEventListener('click', (e) => {
    console.log(e.target.innerHTML)
}, false)
```

**事件代理的好处**：

1. 减少内存的使用，只用给一个元素监听事件。
2. 当动态增加或删除节点的时候，不用手动重新监听事件。

```js
var length = 10;
 
function fn() {
    return this.length + 1;
}
 
var obj = {
    length: 5,
    test1: function () {
        return fn();
    }
};
 
obj.test2 = fn;
 
console.log(obj.test1())
console.log(fn() === obj.test2())
// 11
// false
```



2.x与3.x双向绑定原理

vue中的观察者模式举例



合并两个有序数组

多叉树搜索指定节点（BFS）

+ 写个题目吧：数组去重 ，要求：复杂度尽量低，并且需要区分number类型和string类型，做完一版之后又让我优化，复杂度优化到on
+ 跳台阶

```js
function jumpFloor(number) {

if(number === 1){

   return 1

}

if(number === 2){

    return 2

}

if(number > 2){

    return jumpFloor(number-1)+jumpFloor(number-2)

}


```



### vue

+ vue的响应式原理



+ vue中v-if和v-show的区别和使用场景

  

+ vue组件通信方式
  + 父子组件通信，prop，$event
  + 事件总线
  + vuex
+ 父子组件，如何实现父组件更新，子组件不更新
+ 为什么要用vuex
+ vuex的特点
+ 不用vuex如何实现不相关组件的通信
+ 不使用vuex有什么后果，它本身有什么弊端
+ vueRouter的实现方式有哪些

1. **hash模式**

+ `url hash`就是类似于

```js
http://www.xxx.com/#/login
```

这种`#`后面hash值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外hash值的变化还会触发`hashchange`这个事件。

通过`window.location.hash`获取到当前url的hash；

hash模式下通过`hashchange`方法可以监听url中hash的变化

**优点**：**hash模式的特点是兼容性更好，并且hash的变化会在浏览器的history中增加一条记录，可以实现浏览器的前进和后退功能**。

**缺点：**由于多了一个#，所以不够美观

2. **history模式**

HTML5标准发布后，多了两个API`pushState`和`replaceState`,

通过`location.pathname`获取到当前url的路由地址；history模式下，通过`pushState`和`replaceState`方法可以修改url地址且不会发送请求，结合`popstate`方法监听url中路由的变化

**缺点**：**它的劣势也比较明显，当用户刷新或直接输入地址时会向服务器发送一个请求，所以history模式需要服务端同学进行支持，将路由都重定向到根路由**

**优点**：url更加美观

**Vue router实现**

vue-router定义

```js
import VueRouter from 'vue-router'
Vue.use(VueRouter)

const router = new VueRouter({
  mode: 'history',
  routes: [...]
})

new Vue({
  router
  ...
})
```

1. 通过Vue.use的方法被注入进Vue实例中
2. 在使用的时候需要全局用到vue-router的router-view和router-link组件
3. 以及`this.$router`/`$route`这样的实例对象

**vue-router工作流程**：

1. url改变
2. 触发事件监听
3. 改变vue-router中的current变量
4. 监视current变量
5. 获取新的组件
6. render

**Vue.use()**方法用于插件安装，通过它可以将一些功能或API入侵到Vue内部。

它接收一个参数，如果参数有install方法，那么`Vue.use()`会执行这个install方法，如果接收到的参数是一个函数，那么这个函数会作为install方法执行。

install方法在执行的时候也会接收到一个参数，这个参数就是当前Vue实例方法。

通过接收到的Vue实例，可以定义一些全局方法或属性，也可以通过prototype对Vue的实例方法进行扩展。

**Vue.mixin()**方法用于注册全局混入，它接收一个对象作为参数，我们将这个对象称为混入对象。通过混入对象定义的属性和方法在每一个组件中都可以访问到





+ history和hash路由有什么区别、onhashchange事件
+ history模式刷新会出现什么，怎么解决

+ vue的响应式原理

+ vue的生命周期
+ 一般把ajax请求放在哪里，如果我就是想在created里面操作dom怎么弄
+ vue动态路由，动态组件
+ vue-router的原理（hash模式和history模式）
+ 说一下history模式怎么做到改变路由不进行跳转的？
+ Vue2.0的虚拟Dom中diff[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)的复杂度是多少，可以实现一下大概的过程
+ Vue3.0和Vue2.0相比做了哪些改动，在虚拟Dom层面优化了哪些
+ vue的虚拟dom以及diff[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)





### 浏览器，网络

+ 前端怎么实现离线缓存、离线加载。

+ 对比强缓存和缓存分别会返回什么状态码

+ 301和302的区别以及应用场景

+ 怎么获取cookie，怎么阻止cookie

  document.cookie

  把cookie的过期时间设为过去。

+ session是啥，用在哪



除了cookie和localstorage之外还有社么存储方式。

+ indexDB、memory cache、 disk cache

+ 页面渲染中遇到复杂计算造成的卡顿怎么解决？

  在引入js文件的script标签中加defer或者async实现异步加载

  开启一个web worker子线程来计算。

+ 前端还有哪些worker，分别说一下怎么使用以及区别

+ 如何监控页面的卡顿，崩溃

+ input标签里面放script的危险性

可能引起xss攻击

前端攻击有哪些？怎么解决

1. csrf：token
2. xss： 输入输出验证，转义特殊字符。
3. ddos：验证码

+ Etag是干什么的，怎么生成的，为什么有了Last-Modified还要Etag
+ http、https、http2.0区别
  + https为什么更安全？
+ 移动端适配方案
+ 设计模式在前端的应用
  + 观察者和订阅发/发布的区别

+ 浏览器请求的过程



+ tcp三次握手的过程



+ sql优化
+ 浏览器的渲染过程，结合浏览器的渲染过程再解释以下回流浪费性能的原因
+ 回流、重绘是如何触发的
+ js除了删除或增加dom，有哪些属性可以回流，为什么它们可以出发回流
+ 
+ OSI七层模型，各个层都在干什么
+ 如果解析到了html文件，浏览器如何渲染
+ xss如何防护
+ 客户端页面一直是白屏的，而我们观察是正常的如何排查问题、
+ websocket有什么特点
+ http的缓存了解吗？分别的响应头是啥，如何设置资源过期时间，场景有想过应用吗
+ 页面卡顿原因是什么，分析一下
+ 快排的时间复杂度，快排稳定吗？你有什么优化方式
+ 跨域的复杂业务场景
+ 假如让你设计一个场景将一个请求分发到不同的服务器上你有什么策略和思路
+ 知道cookie吗？cookie会有跨域问题吗？子域能获取到父域的cookie吗？

cookie：最基本的一种行为就是本地存储，将用户用到的一些数据记录到本地，以便它下次访问的时候拿到

+ 从输入地址到返回请求。

ke.qq.com

1. 通过DNS系统查找ip地址
2. 打包成http包
3. 逻辑网络 (tcp/ip)  物理网络  逻辑网络
4. 拆包（http）

网络体系结构

+ tcp/ip四层协议

1. 应用层： tcp  udp
2. 传输层： dns  http smtp pop3 imap
3. 网际层： ip
4. 网络接口层： 物理网络

dns选择udp协议

htttp选择tcp协议

+ 五层协议

1. 应用层： tcp  udp

2. 传输层： dns  http smtp pop3 imap

3. 网际层： ip

4. 将网络接口层分为两层

   + 2. 数据链路层

   + 1. 物理层

+ osi七层协议

**TCP**：**传输控制协议**

​	是一种面向连接的可靠的基于字节流的传输层通信协议

创建连接

数据传送

终止连接

**HTTP**：**超文本传输协议**

​	是一种用于分布式、协作式和超媒体信息系统的应用层协议



**HTTP状态码**

1. 404的含义就是客户端所访问的资源不存在
2. 304
3. 301永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
4. 302临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
5. 500服务器内部错误，无法完成请求

+ 浏览器的缓存

cache-control： 相对时间，优先级高于expires

expires:绝对时间，服务器时间



last-modified：文件最后修改的时间

if-modified-since：



etag：xxxx   哈希值

if-None-Match：xxxx



**DNS**：域名解析系统,应用层

三级域名.二级域名.顶级域名   ke.qq.com

根域名服务器

顶级域名服务器	

​	顶级域名：com org net cn hk

权限域名服务器

​	二级域名	qq google baidu taobao

​	三级域名	ke www

​    四级域名	imweb.ke.qq.com

### 性能与工程化

##### 1. html怎样解析成一棵dom树

html(文本)/css/js——词法解析拆分成token——根据规范语法解析扫描——生成dom树

html——词法解析——语法解析——DOM树

文本形式————————————对象形式

##### 2. DOM树和渲染树

一般情况下一一对应，可显示的元素

设置了定位的与元素一般会脱离正常的render流

##### 3. 重排和重绘

**重排 reflow**  几何属性·

+ 页面第一次渲染
+ 浏览器窗口尺寸改变
+ 元素位置和尺寸
+ 新增和删除可见元素
+ 内容改变

**重绘 repaint**   color background-color

有重排一定有重绘，有重绘不一定会重排





#### 从输入地址到页面渲染

### 安全攻防战

#### 1. cookie

获取cookie

decodeURLComponent(document.cookie)

encodeURLComponent

获取cookie

增加cookie

删除cookie

domain



#### 2.web安全

##### 1. XSS攻击

+ **XSS攻击**：跨站脚本攻击

1. 往网页里面注入恶意脚本代码。
2. 当用户访问时，获取到包含恶意代码的网页
3. 通过恶意脚本，坏人可以获取和控制用户信息。

+ **分类**：

XSS跨站脚本攻击：

**1. 反射型(非持久型)XSS**：诱导用户点击恶意链接来造成一次性攻击

1. 访问带有恶意脚本代码参数的URL。

2. 服务端获取请求参数且直接使用。

3. 服务端”反射“回结果页

4. 用户中招

**特点**：

+ 一次性（非持久性）
+ 通过用户点击链接引起

**2. 存储型(持久型)XSS：**恶意代码存储到漏洞服务器中，用户浏览相关页面发起攻击

服务端存储了评论，但没有对评论进行加工。

1. 将恶意代码上传或存储到漏洞服务器。
2. 服务端就会直接存储恶意代码的数据
3. 用户访问相关包含恶意代码的页面
4. 服务端直接读取而恶意数据，且直接使用。
5. 服务器未防范返回含有恶意脚本的页面
6. 用户中招

**比较**：

1. **反射型XSS**： 非持久化、需要用户点击
2. **存储型XSS**：持久化、不需要交互也可触发

**3. DOM-Based型XSS**：基于浏览器DOM解析的攻击，在前端操作DOM的时候，一些带有恶意代码的片段被HTML解析执行从而导致DOM-Based型XSS

1. 用户打开带有恶意的链接
2. 浏览器（客户端）在DOM解析时直接使用恶意数据
3. 用户中招

场景:修改dom

**区别**： 前两种都需要服务端的直接参与解析

+ 反射型XSS需要服务端去获取请求中的参数，通过使用请求中的参数并且解析生成结果页返回给前端而触发的。
+ 存储型XSS服务端存储了恶意脚本代码，当前端访问的时候，服务端会将恶意代码返回给前端。
+ 在前端操作DOM的时候，一些带有恶意代码的片段被HTML解析执行从而导致DOM-Based型XSS



 **XSS payload**：实现XSS攻击的恶意脚本

+ 窃取用户cookie	document.cookie
+ 识别用户浏览器    navigatior.userAgent
+ 伪造请求   get/post
+ XSS钓鱼   XSS payload + 钓鱼网站

**XSS钓鱼**：

通过XSS payload王页面注入一些钓鱼的网站链接，诱导用户去访问，从而实现响应的攻击。

##### XSS 防御	httpOnly

+ 给cookie设置httpOnly：组织客户端脚本访问Cookie

  + 自己也不能用，非根本性

+ **输入检查**：

  + 判断输入格式，白名单

  + 黑名单  

    过滤危险字符：去除<script>,javascript,onclick、

    转义特殊字符:  < ——>`&lt;`

    ​						  >——>`&gt;`

    ​						  &——>`&amp;`

    ​						   \——>`&quot;` 

**前端结合服务端实现输入检查**

之所以会发生XSS攻击，就是由于用户的输入别当作代码执行，导致出现意料之外的运行结果。用户数据被填充到HTML代码中，可能存在以下五个场景：

- HTML 标签中（用户输入将在 HTML 解析环境进行）

- HTML 非事件属性中（用户输入将在 HTML 解析环境进行）

- script 标签中 （用户输入将在 JavaScript 解析环境进行）

- HTML 事件属性中（用户输入将在 JavaScript 解析环境进行）

- 地址栏中（用户输入将在 URL 解析环境进行）

为了避免我们用户输入被当做代码来执行，因此我们需要对用户输入中存在的特殊字符做一些处理。处理规则很简单，就是：

  - HTML 解析环境使用 **HtmlEncode**
  - JavaScript 解析环境使用 **JavaScriptEncode**
  - URL 解析环境使用 **URLEncode**

+ **输出检查**：

最后一道防线，根据不同的场景对数据进行处理。



##### 2. CSRF:  跨站请求伪造

​	用户不知情：	验证码

​	跨站请求：    使用refer验证，request.header.referer,不可靠，可能被篡改。

​    参数伪造：	**token**

**CSRF防御操作**



##### 3. XSS与CSRF结合

1. 登录
2. 服务器setCookie
3. 使用脚本发起转账请求

通过XSS插入脚本，攻击者就不需要诱导用户访问钓鱼网站，而是可以直接在原站点发出伪造的请求。

XSS和CSRF配合使用，一般的CSRF防御方式，比如referer验证，token验证等都有可能会失效。最好使用验证码的方法防御。

**防御**：验证码

##### 4. XSS蠕虫

+ 用户交互的页面
+ 不断传播的XSS+CSRF的脚本攻击

+ XSS蠕虫本质上是CSRF+XSS攻击
+ XSS蠕虫通常发生在社交网站等用户交互比较多的网站，因为存在可以传播的内容载体
+ XSS蠕虫会在用户之间不断传播，所以一般影响范围很广
+ 只要做好XSS和CSRF防御，就能有效地防御XSS蠕虫。

##### 5. DDOS分布式拒绝服务：

是指攻击者利用大量”肉鸡“(非正常的请求)对目标发动大量的请求导致目标目标耗尽资源，（来耗尽我们服务器的资源，使得我们的服务不能正常的运行。）

1. 坏人控制大量”肉鸡“
2. ”肉鸡“非正常请求
3. 目标主机耗尽资源，不能为合法用户服务。

遭受到DDOS攻击，可能会出现网站瘫痪，普通用户无法访问等现象。

一些大型的活动如”淘宝双十一“需要做好DDOS防范，防止由于大量请求和流量导致网站瘫痪。

**防御**：

1. 验证码
2. 限制请求频率：原理为设置每个客户端的请求频率的限制。
3. 扩容加带宽：增加机器服务带宽。只要超过了攻击流量便可以避免服务瘫痪。



##### 6. 运行商HTTP劫持

利用了HTTP明文的特性，篡改了服务端发送给客户端的内容

**HTTPS**:	HTTP + SSL/TSL（传输层安全协议）

+ 服务端利用密钥解密

+ 窃听者不会解密，所以无法篡改监听到的页面

+ 返回页面给客户端，客户端通过密钥对内容进行解密

SSL： 加密算法、密钥协商、服务端验证。

**对称加密**：加密解密用的同一条密钥

**非对称加密**：密钥成对出现，通常其中一条不公开，叫私钥，另一条是公开的，称为公钥。用其中一条加密的内容只能用另一条解开。

1. 客户端请求https连接
2. 服务端返回公钥，自己保存一个私钥。
3. 客户端产生对称密钥
4. 客户端使用公钥对对称密钥进行加密
5. 客户端发送加密后的对称密钥
6. 服务端使用私钥解密得到对称密钥
7. 服务端返回经对称密钥加密的页面内容
8. 客户端使用对称密钥解密得到未知的页面内容。
9. 客户端和服务端可以使用对称密钥进行通信了。

**利用==非对称加密算法==在客户端与服务器之间协商得到==对称密钥==**

**注意**：公钥可能被窃听

数字认证机构(CA)：服务器公钥的合法性

1. 客户端请求https连接
2. 服务端向数字认证机构（CA）申请证书，返回证书（包含公钥），自己保存私钥
3. 客户端获取到证书后，就回去询问CA，问这个证书是否合法。

**查询过程**：

**迭代查询：**

IP地址 —— 先去本地域名服务器，本地域名服务器查不到，

​					本地域名服务器到根域名服务器查找，如果根域名服务器查不到

​					本地域名服务器就到顶级域名服务器查询，如果查不到

​					本地域名服务器就到权限域名服务器查询

**递归查询：**



IP地址 ——	先去本地域名服务器查找，本地域名服务器没有就去根域名服务器查找

​						根域名服务器查不到，根就发送一个请求去顶级域名服务器查

​						顶级域名还有没有，顶级域名发送请求到权限域名服务器查



+ 懒加载怎么实现

### 算法

+ 找到字符串中出现次数最少的字符



### 前端优化

+ 如何理解前端性能



+ 前端性能优化

+ 前端优化有哪些手段
+ 有一个无限循环的长列表，你会怎么优化
+ 首页白屏怎么排查
+ 移动端
+ 动画掉帧怎么办
+ 回流的时候浏览器做了什么
+ 那我有一些回调事件，在16.7ms内渲染不完，怎么办？为什么是16.7ms？
+ 内存泄漏内存溢出的区别



## 题

+ 如何实现一个红绿灯？初始为绿灯，间隔3S后变为黄灯，间隔1S后变为红灯，间隔2S后变为绿灯。两种方式代码实现一下。（利用节流函数类似的方法实现了一种，promise的api一慌给忘了。难受，只能讲一下思路）
+ 给定一个树形的数据结构，如果有子节点就定义为ul，没有就定义为li，解析并添加到页面上



```js
b()
console.log(a)
var a = 'hello world'
function b() {
    console.log('call b first')
}
function b() {
    console.log('call b second')
}
// call b second
// undefined
```

+ x_x

```js
var x = 1
var y = 2
var z = function () {
    var x = 2
    return {
        x:x,
        y: function(a,b) {
            x = a + b
        },
        z:function() {
            return x
        }
    }
}
a = z()
a.y(x,y)
console.log(a.z(), a.x, x)
```



### 智力题

1.  用3升，5升杯子怎么量出4升水？
2. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？
3. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？
   + 最多60%，喜欢足球的60%人其他两种都喜欢
   + 最少10%    （有最多90%地人三种球中有一种球不喜欢）
4. 100个乒乓球、甲乙一次可以拿一到五个、甲先拿的话怎么能最后一个拿完

## 总结



### 1. 防抖和节流

### 2. 垃圾回收机制



### 3. 跨域及常见解决办法



### 4. 前端本地存储



### 5. 浏览器缓存



### 6. CSRF攻击流程

要完成一次CSRF攻击，受害者必须依次完成两个步骤

+ 1. 登录受信任网站A，并在本地生成Cookie。
+ 2. 在不登出A的情况下，访问危险网站B。





### 7. 前端鉴权

大概的流程是这样的：

- 1, 客户端使用用户名跟密码请求登录
- 2, 服务端收到请求，去验证用户名与密码
- 3, 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
- 4, 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
- 5, 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
- 6, 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

总的来说就是客户端在首次登陆以后，服务端再次接收http请求的时候，就只认token了，请求只要每次把token带上就行了，服务器端会拦截所有的请求，然后校验token的合法性，合法就放行，**不合法就返回401**（鉴权失败）。

#### Token优点与缺点

**优点**：

+ Token完全由应用管理，所以它可以避开同源策略。（Cookie是不允许跨域访问的，token不存在）
+ Token可以避免CSRF攻击（也是因为不需要cookie了）
+ Token可以是无状态的，可以在多个服务间共享。
+ Token支持手机端访问（Cookie不支持手机端访问）

**缺点**：

+ 占带宽：正常情况下token要比session_id更大，需要消耗更多流量，挤占更多带宽（不过几乎可以忽略）
+ 性能问题：相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证。其实Token相比于session-cookie来说是一个“时间换空间"的方案。

#### Token与session的区别

+ 使用Token，服务端不需要保存状态
+ Token不需要借助cookie
+ 时效性
+ 可扩展性

### this

+ 函数在js中被说成是first class的原因是
  + 函数可以作为函数的参数和返回结果，并且可以赋值给变量。

+ this就是执行环境，当调用函数的时候，函数肯定有个执行环境
  + 全局作用域  this->window
  + 作为对象的方法 this->对象
+ this是在调用的时候决定的，也就是函数的执行环境，作用域，是在调用的时候生成的。

```js
function createScope(member) { // 创建私有方法的手段就是闭包
    return function() {
        return member
    }
}

const getCpp = createScope('cpp') // 不可修改的变量，私有变量
getCpp()
const getLg = createScope('lg')
getLg()
```

### 闭包cursor

+ **闭包**是指有权访问另一个**函数作用域**中变量的**函数**。

```js
function foo() {
	const a = 'test'
    function bar() {	// 闭包，可以访问父级函数作用域
        console.log(a)
    }
    bar()
}
foo()
```

+ 闭包是一个带有数据的函数

```js
function foo() {
    const a = 'test'
    // 外面调用函数foo，返回的就是bar函数
    function bar() {
        return a
    }
    return bar
}
// 
const bar = foo()
bar()
// "test"
```

+ 特权方法：我们也把有权访问私有变量和私有函数的公有方法称为**特权方法。**

### instanceof

+ 原生构造函数
+ 构造函数
  + 没有显示的创建对象
  + 将属性和方法赋值给this
  + 没有return语句

### new操作符

+ 

### 构造函数

```js
function Person(name, age, sex) {
    this.name = name
    this.age = age
    this.sex = sex
    this.sayHello = function() {
        console.log(this.name)
    }
}
const p = new Person('cjz', '2', 'boy')
```

+ **构造函数的不足之处**：功能相同的函数，重复声明消耗空间。

  **解决方法**： 原型

**原型**

+ **原型**是函数的一个属性，是一个对象。如果·函数作为构造函数使用，那么这个构造函数的所有实例，都**共享**这个原型对象。

**constructor**

```js
Object.prototype
Object.prototype.constructor
Object.prototype.constructor === Object
// true
// 当我们的函数声明以后，经过一系列的规则，会生成一个prototype原型对象，它会默认挂一个属性，叫constructor，指向它的构造函数。

```

**原型的缺陷：**本质上就是共享的缺陷。

+ 数据污染

**完美的常见对象的方式**：构造函数结合原型。

+ 构造函数独享属性
+ 原型共享方法

**属性覆盖**：实力上的属性会覆盖原型上的属性，查找的过程。

**属性的判断**:

+ in操作符：只要对象上有这个属性，就为true，不管在对象上还是原型上
+ hasOwnProperty：判断属性到底在实例上还是原型上，只有在实例上才为真。

### 继承

**定义**：**继承**可以使子类具有**父类**的**属性和方法**，而不需要重复编写相同的代码。

**原型链**：将子类和父类的原型串了起来。

1. 打通原型链

```js
Fighter.prototype = new Plane('blue') //将原型指向了父类的实例。
```

**缺陷**：

+ constructor的指向问题。

```js
Fighter.prototype = new Plane()
Fighter.prototype.constructor = Fighter
console.log(fighter.constructor) // Fighter
```



+  属性共享问题:引用类型，数据污染。

+ 参数

2. 借用构造函数继承：利用函数可以指定它的执行环境

```js
Plane.call(this, color)
```



+ 借用父类构造函数
+ 可以传递参数

**缺陷**：借用构造函数不能单独使用，原型上的所有方法都继承不了。

3. 组合继承

原型链继承（继承原型属性和方法）+借用构造函数继承（继承了实例上的属性）

+ 属性和方法都是从父类继承的（解决了代码复用）
+ 继承的属性是私有的（互不影响）

+ 继承的方法都在原型里（函数复用）

、

```js
function Plane (color) {
    this.color = color
}
Plane.prototype.fly = function() {
    console.log('flying')
}
function Fighter (color) {
    Plane.call(this, color)	// 这里也调用了一次构造函数
    this.bullets = []
}
Fighter.prototype = new Plane()  // 这里调用了一次构造函数
Fighter.prototype.constructor = Fighter
Fighter.prototype.shoot = function() {
    console.log('biu biu biu')
}

```

**缺陷**：

+ 重复调用
+ 属性冗余



4. 最佳实践

+ 基于组合继承
+ 不必重复调用父类构造函数，只需继承原型

```js
inheritPrototype(Fighter, Plane)
function inheritPrototype(subType, superType) {
    const protoType = Object.create(superType.prototype); // 复制父类的原型
    protoType.constructor = subType	// 重置constructor
    subType.prototype = protoType;	// 将子类的圆形赋值给protoType
}
```

另一种方法

```js
function inheritPrototype(child, parent) {
    const Temp  = function() {}	// 这里必须为一个空函数
    Temp.prototype = parent.prototype
    child.prototype = new Temp()
    child.prototype.constructor = child
}
```

```js
function Person(name) {
    this.name = name;
}
Person.prototype.sayHello = function() {
    console.log('Hi! My name is ' + this.name + '.');
}
function Student(name, grade) {
    Person.call(this, name)
    this.grade = grade;
}
inheritPrototype(Student, Person)  // 注意，该函数的调用必须在下面一句函数的起那面
Student.prototype.sayGrade = function() {
    console.log('I am Grade ' + this.grade + '.');
}
// TODOS 完成继承原型的函数
function inheritPrototype(subType, superType){
    const protoType = Object.create(superType.prototype)
    subType.prototype.constructor = subType
    subType.prototype = protoType
}

// 可以正确运行下面代码：
var student = new Student('Cover', 4);
console.log(student.name); // 'Cover'
student.sayHello(); // 'Hi! My name is Cover.'
student.sayGrade(); // 'I am Grade 4.'
student.hasOwnProperty('name');  // true
```

**es6中的继承**

```js
//定义类
class Person {
    // 构造函数
    constructor(name) {
        this.name = name;
    }

    // 方法
    sayName() {
        console.log(this.name);
    }
}

//定义类
class Student extends Person {
    // 构造函数
    constructor(name, grade) {
        super(name);
        this.grade = grade;
    }

    // 方法
    sayGrade() {
        console.log(`I am Grade ${this.grade}`);
    }
}
```

### 缓存

from disk cache: 硬盘缓存，没有发送请求，非常快

from memory cache： 缓存到内存

cache-control：相对时间，cache-control: max-age=20,优先级高于expires

expires:绝对时间，格林尼治时间，服务器时间

last-modified： 响应头，文件最后修改时间

if-modified-since：浏览器发送到头，保存的就是last-modified

### 浏览器和缓存引擎

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216100718240.png" alt="image-20210216100718240" style="zoom: 50%;" />

**渲染引擎**：

谷歌：Blink

IE： Trident

Safari：Webkit

火狐：Gecko

Opera：Blink

HTML(文本)——>DOM树(对象)

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216101337902.png" alt="image-20210216101337902" style="zoom:50%;" />

HTML——>DOM Tree

CSS——>样式规则

二者结合生成Render Tree

![image-20210216101904607](C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216101904607.png)

+ DOM Tree和Render Tree一般情况下是一一对应的
+ 可显示的元素：Render Tree是可见的元素，比如有些元素设置了`display: none`,Render Tree里面没有，但是DOM Tree里面有。
+ 定位的元素：比如设置了fixed、absolute的元素一般会脱离常规的Render流程。

（比如有些设置为`display:none`或者·脱离文档流，会减少对Render Tree的干扰，painting、的更加快）

**渲染树在构建过程中会给元素布局（Layout），也叫重排（Reflow），之后就开始绘制（Painting）**

**重排**：reflow （layout）

+ 几何属性
  + 页面第一次渲染
  + 浏览器窗口尺寸改变
  + 元素位置和尺寸
  + 新增和删除可见元素
  + 内容改变

**重绘**：repaint

+ 比如color、background-color

**有重排一定有重绘，有重绘不一定有重排**

减少触发重排

#### **从输入地址到页面渲染**：

HTML——>ke.qq.com——>缓存（如果没有缓存，就发送HTTP请求发送HTTP请求之前还要通过DNS域名解析系统，查找IP地址）

有了HTML后——>DOM Tree——>Render Tree(Render Tree往往伴随着layout)——>paint——>然后才是页面

浏览器是多线程的，收到页面后GUI渲染线程先解析页面，等到遇到script的时候，使用js引擎线程（主线程），执行js代码。当一个宏任务执行完成之后，宏任务队列会把新的宏任务交给主线程执行。

工作线程：

http请求线程、定时器线程、事件线程





##### GUI渲染线程主要工作内容

- 解析html文档生成DOM
- css代码转换为cssom (css object model)
- 结合DOM和CSSOM生成渲染树
- 生成布局（layout）
- 将布局绘制(paint)在屏幕上

js线程的一般调度策略是：js线程从宏任务中选取一个任务执行，执行完成后，逐个执行微任务中的任务直至微任务为空，然后再次从宏任务中选取一个任务执行，如此反复。js线程从宏任务中选取一个任务开始到执行完所有微任务为止称为一个事件循环。

```js
// 宏任务 --> 所有微任务 --> 渲染（如果时间片到了） --> 宏任务...
document.body.style = "background:blue";
console.log(1);
setTimeout(function fn() {
  document.body.style = "background:black";
  console.log(2);
}, 1000);
```

执行过程：

1. script作为宏任务执行，打印1；
2. 渲染，背景蓝色
3. 执行宏任务fn，打印2
4. 渲染，背景黑色

### 性能

**性能**：影响用户体验，影响网站收益

+ 检测网页性能API：`window.performance`,高精度测量网站性能。

可获取网络连接、dns、加载等性能数据。

performance详解

+ **浏览器内存相关**：performance.memory

+ **网页导航相关**：performance.navigation

  +  performance.navigation.type

    该属性的值为一个整数值，表示网页的加载来源，共以下4种情况。
    
  +   performance.navigation.redirectCount

     该属性表示到达当前页面，经过重定向的次数。

+ **事件相关**：performance.timing

+ **资源加载相关**： performance.getEntries()

**打开一个页面的时候**：

开始请求——>获取首字节（performance.timing.responseStart）——>页面开始展示（用户屏幕开始显示内容的时间，白屏时间）——>首屏内容加载完成（不滚动屏幕，能看到的内容加载完成的时间点，首屏时间）——>加载完成

+ **白屏时间：**从网页开始发起请求，到用户屏幕开始显示内容，为白屏时间。
  + 白屏时间 = 页面开始展示的时间点 - 开始请求的时间点
  + 按照文档流从从上到下解析——>开始解析head——>结束解析完head（开始解析body，通常认为开始解析body为开始看到内容）——>解析完body
    + 非可视化的DOM元素不会显示到窗口中，例如`<head>`,这就意味着浏览器在绘制之前，至少需要先解析完head元素中的内容。

+ 白屏时间 = endTime - performance.timing.navigationStart

  当浏览器不支持performance时，白屏时间 = endTime - startTime

  ```html
  !DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <script>
      // 测试时间起点
      const start = +new Date()
      // window.pageStartTime = Date.now();
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/style.css">
    <script>
      // 测试时间终点，页面开始展示的时间点
      const endTime = +new Date()
      // window.firstPaint = Date.now();
    </script>
  </head>
  <body>
    <ul>
      <li>1. 白屏时间 = endTime - performance.timing.navigationStart</li>
      <li>2. 白屏时间 = firstPaint - performance.timing.navigationStart</li>
      <li>1. 当浏览器不支持performance时，白屏时间 = endTime - startTime</li>
      <li>2.当浏览器不支持performance时，白屏时间 = firstPaint- pageStartTime</li>
    </ul>
  </body>
  </html>
  
  ```

+ **首屏时间**：是指用户首屏内容全部加载完成的时间
  
  + 首屏时间 = 首屏内容全部加载完成的时间 - 页面开始请求的时间点

**计算白屏时间**：因此我们通常认为浏览器开始渲染`<body>`标签或者解析完`<head>`标签的时刻就是页面白屏时间点

#### 业务中如何计算白屏和首屏时间：

1. **首屏标签标记法**
2. **统计首屏内图片加载完成的时间**：通常我们首屏加载最慢的就是图片资源，因此我们会把首屏内加载最慢的图片的时间当作首屏的时间。

+ 此时首屏时间等于：`加载最慢的图片的时间点 - performance.timing.navigationStart`

3. **自定义模块内容及算法**

+ 忽略图片等资源加载情况，只考虑页面主要DOM
+ 只考虑首屏的主要模块，而不是严格意义首屏线以上的所有内容。



### 网页优化手段

1. 减少请求文件数
2. 减少资源体积
3. 提高网络传输

**请求主要耗时**：

+ 请求变多——>页面加载变慢，服务端压力变大

  + 减少请求数：
    1. 小图片合并雪碧图或者使用iconfont
    2. JS、CSS文件合并

+ 减少资源体积

  1. 精简代码
  2. 压缩CSS、JS、图片
  3. 开启Gzip，可以将资源在**服务端**进行压缩，然后发送给浏览器后再进行解压，这种方式会降低传输大小，提高网页加载性能。

+ 提高网络传输

  1. 使用浏览器缓存：浏览器缓存只能提升二次访问的速度。
  
  ​	2. 使用CDN(内容分发网络)：对于加速首次访问的速度，我们常见的手段就是使用CDN加速。

**会把服务器的内容复制一份到CDN上**

  ### 模块

**IIFE立即执行函数表达式**:

+ 创建私有作用域
+ 避免变量冲突

  **使用立即执行函数表达式实现模块**

  ```js
  // 包裹代码模块
  // 暴露模块属性和接口
  const moduleB = (function() {
    const b = 0  // 设置模块B的变量
    function methodB() {
        
    }
    // 模块B方法 keepMoving
    function keepMoving() {
        
    }
    // 只暴露keepMoving方法
    return {
    	keepMoving: keepMoving
    }
  })()
  ```

//  {keepMoving: ƒ}
//	keepMoving: ƒ keepMoving()
//	__proto__: Object
  ```

**模块依赖**

**模块化规范**：主要是为了解决命名冲突和模块间依赖管理的问题

1. CommonJS

+ 文件即模块
+ 使用`module.exports(exports)`暴露对外的接口
+ 使用`require`同步加载依赖模块

**commonJS**同步加载模块

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216191708169.png" alt="image-20210216191708169" style="zoom:50%;" />

2. AMD异步模块定义

+ define定义模块

+ 使用require调用模块

3. CMD通用模块定义

## webpack



### 设计模式

**设计模式**是解决软件设计常见问题的可复用方案。

**反模式**：是一种针对某个特定问题的不良解决方法，该方案会导致槽糕的情况发生。要避免出现反模式

+ 定义大量污染全局命名空间的变量
+ 修改Object类的原型
+ 使用document.write创建页面、
+ 硬编码，写死功能等等

**观察者模式**：发布-订阅者模式

**MVC模式**：

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216231600061.png" alt="image-20210216231600061" style="zoom:50%;" />

**MVVM模式**：

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216232459771.png" alt="image-20210216232459771" style="zoom:50%;" />

### cookie

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210216233706743.png" alt="image-20210216233706743" style="zoom:50%;" />+

+  js 的变量可以保存信息，但是变量是有生命周期的，一旦页面刷新，包括全局变量在内的所有变量都会销毁，所以变量没法保存持久化的信息。而 cookie 实际上是在保存在浏览器本地的信息，它们储存的信息会保存在本地文件中，就算页面刷新了，信息也还是存在。
+ 我们可以通过 `Expires` 字段设置 cookie 过期时间，设置了过期时间的 cookie 就是持久化 cookie， 只有超过过期时间 cookie 才会失效，关闭浏览器并不会使持久化 cookie 失效

+ 没有设置过期时间的cookie叫临时cookie，关闭浏览器就会失效
+ cookie 虽然可以储存本地信息，但是不适合储存大量的信息，因为 cookie 还有个特点是每次请求都会带上这个域相关的所有 cookie，就是说，cookie 会影响浏览器请求的大小，因此我们要尽量保持 cookie 体积小，还有尽量用于保存跟用户相关的信息。同时，浏览器本身对 cookie 总大小也有限制，目前是不允许超过 4k，超过的会丢失。

+ cookie 适用于数据量比较小的，跟用户信息相关的储存，而如果要储存相对量比较大的数据，而且这些这些数据不需要随着请求发到服务器的话，则可以使用 [`localStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)

​```js
// 获取cookie
document.cookie
// 自定义一个getCookie方法
  ```



+ 简单封装cookie

```js
/**
 * 实现简单 cookie 封装库
 */

 // Cookie 对象
 Cookie = {
    /**
     * TODOS: 实现 cookie 设置方法
     * @param {String} name 属性名
     * @param {String} value 属性值
     */
    set: function(name, value) {
        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value)
    },
    /**
    * TODOS: 实现 cookie 获取方法
    * @param {String} name 属性名
    * @return {String} 返回对应的属性值
    */
    get: function(name) {
        var nameStr = name + "=";
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for(var i = 0; i <ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(nameStr) == 0) {
                return c.substring(nameStr.length, c.length);
            }
        }
        return "";
    },
    /**
    * TODOS: 实现 cookie 删除方法
    * @param {String} name 属性名
    */
    remove: function(name) {
        document.cookie = encodeURIComponent(name) + '='
        + '' + ';Expires=' + new Date(0);
    }
}
// 正确运行下面代码
Cookie.set('username', 'kevin'); // 增加 username=kevin cookie
Cookie.get('username'); // kevin
Cookie.remove('username'); // 删除 username=kevin cookie
```

**登陆**

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217001119904.png" alt="image-20210217001119904" style="zoom:50%;" />

**注销**：让cookie失效

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217001143332.png" alt="image-20210217001143332" style="zoom:50%;" />

### 网络安全

**1. XSS攻击：**跨站脚本攻击-黑客在网站中注入恶意代码

+ 反射型（非持久型）XSS：诱导用户点击恶意链接来造成一次性攻击。

  + 非持久化
  + 需要用户点击

+ 存储型（持久型）XSS：恶意代码存储到漏洞服务器中，用户浏览相关页面发起攻击

  + 持久化（存储在服务器）
  + 不需要交互也可以触发

+ DOM-Based型XSS：基于浏览器客户端DOM解析的攻击

  常出发场景：innerhtml、outerhtml、document.write

**XSS防御**：给cookie设置httpOnly

+ 阻止客户端脚本访问Cookie

**除了在前端做输入检查，还要在服务器做输入检查**

白名单：

黑名单：

输出检查：最后一道防线，分局不同场景对数据进行处理

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217091108771.png" alt="image-20210217091108771" style="zoom:50%;" />

**之所以会发生 XSS 攻击，就是由于用户的输入被当做代码来执行，导致出现意料之外的运行结果**

用户数据被填充到 HTML 代码中，可能存在以下五个场景：

- HTML 标签中（用户输入将在 HTML 解析环境进行）
- HTML 非事件属性中（用户输入将在 HTML 解析环境进行）
- script 标签中 （用户输入将在 JavaScript 解析环境进行）
- HTML 事件属性中（用户输入将在 JavaScript 解析环境进行）
- 地址栏中（用户输入将在 URL 解析环境进行）

为了避免我们用户输入被当做代码来执行，因此我们需要对用户输入中存在的特殊字符做一些处理。处理规则很简单，就是：

- HTML 解析环境使用 **HtmlEncode**
- JavaScript 解析环境使用 **JavaScriptEncode**
- URL 解析环境使用 **URLEncode**

**2. CSRF**

**注意，不能用同一个浏览器同时登录两个账号的，因为会覆盖cookie**

+ **CSRF原理**：跨站请求伪造，拿到cookie，伪造你的身份发请求

**案例**：银行转账

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217101156376.png" alt="image-20210217101156376" style="zoom:50%;" />

+ 用户不知情： 使用验证码(不常用来防御csrf，影响用户体验，用来防御ddos)
+ 跨站请求： 使用refer验证（不可靠，可能被篡改）
+ 参数伪造： token是最主流的防御csrf的手段之一

**3. XSS与CSS结合**

**防御**：验证码在这里可靠，refer没有用，因为是在同一个站点下发的请求

+ XSS 可以在原网站中插入脚本，直接发出伪造请求

+ 正因为 CSRF 伪造的请求可以通过 XSS 在原网站发出，所以 referer 验证已经失效了，另外，XSS 插入的脚本甚至可以直接获取或者间接算出服务器返回给你的 token，也就是说 token 验证也有可能会失效

**4. XSS蠕虫**：用户交互的页面，影响范围广

不断传播的XSS+CSRF攻击

**5. DDOS攻击**：分布式拒绝服务（比如占位不点单），通过大量非正常的请求，来耗尽我们服务器的资源，使得我们服务不能正常运行

**概念**：**DDOS(Distributed Denial of Service)**的缩写，中文意思是“分布式拒绝服务“攻击。其是由于攻击者利用大量**肉鸡(slave)**对攻击目标发动大量请求、导致目标主机耗尽资源或网络资源，从而导致被攻击的目标主机不能为合法用户提供服务。对于一些大型活动（短时有大量用户访问的），需要做好 DDOS 防范，以及对自身网站服务做好扩容的工作。

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217112503701.png" alt="image-20210217112503701" style="zoom:50%;" />

**防范**：

**1. 验证码**：

**2. 限制请求频率**：其原理为设置每个客户端的请求频率的限制。简单来说就是通过一些标识（如IP与Cookie）来定位一个客户端，如果该客户端的请求在一定时间内过于繁琐。则对该客户端之后的请求都定向到一个出错的页面或者封杀相关IP。

当然许多框架都会有相应地限制请求频率的工具包，如 `koa` 框架便可以使用下面这些：

- [koa-limit](https://github.com/cnpm/koa-limit)
- [koa-ratelimit](https://github.com/koajs/ratelimit)

**3. 扩容加宽带**：简单来说，就是增加机器增加服务带宽。只要超过了攻击流量便可以避免服务瘫痪。

**4. HTTP劫持**:http是明文

防御：使用https

**HTTPS**：HTTP+SSL，SSL也可以称之为TSL（传输层安全协议）



<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217122540211.png" alt="image-20210217122540211" style="zoom:50%;" />

**HTTP**

超文本传输协议 **HTTP协议** 用于在 Web 浏览器和网站服务器之间传递信息。然而由于 HTTP 协议其特性是在传输过程中是明文方式的，即不提供任何方式的数据加密。这也导致了当攻击者截取了这之间的传输报文，就可以直接读懂其中的信息和窥视和篡改。这也是 HTTPS 出现的原因。

**安全的 HTTPS**

为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：HTTPS。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 **SSL(安全套接字层)** 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。SSL 标准化改名为 TLS, SSL/TLS 在传输层对网络连接进行加密。

**HTTPS原理**：

+ 对称加密：加密解密用的同一条密钥。
+ 非对称加密：密钥成对出现，通常是其中一条不公开，叫私钥，另一条是公开的，称为公钥。用其中一条加密的内容只能用另一条解开。

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217124040179.png" alt="image-20210217124040179" style="zoom:50%;" />![image-20210217124404838](C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217124404838.png)

<img src="C:/Users/wang/AppData/Roaming/Typora/typora-user-images/image-20210217124509007.png" alt="image-20210217124509007" style="zoom:50%;" />

**通过CA我们可以有效的验证公钥是否是合法的，防止黑客（窃听者）去窃听我们服务端传送的公钥，从而保证我们在传输过程中不会被篡改**



## 面试

### 二、JavaScript

**基本数据类型**：String、Number、Boolean、Undefined、Null、Symbol

**引用类型**：Object

引用类型除Object外，还包括Function、Array、RegExp、Date等等

#### 数组

##### 1. 判断是不是数组

+ `isPrototypeOf()`方法用于测试一个对象是否存在于另一个对象的原型链上。

```javascript
const arr = []

arr instanceof Array

Array.prototype.isPrototypeOf(arr)

arr.constructor === Array

Object.prototype.toString.call(arr) === "[object Array]"

Array.isArray(arr)
```

##### 2. 转化为数组

+ es6提供了新的数据解构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
+ Set本身是一个构造函数，用来生成数据结构。Set可以接受一个数组（或具有iterable接口的其他数据结构）作为参数，用来初始化。
+ 一个数据结构只要具有iterator接口，就可以用`for...of`循环遍历它的成员
+ `for...of`循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如`arguments`对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。

```js
const set = new Set([1, 2])
// 类数组以及部署了遍历器接口的对象
Array.from(set)
[...set]	// 扩展运算符和Set结合，数组去重

// 只能转化类数组对象(arguments和Nodelist)
Array.prototype.slice.call(arguments)
```

##### 3. 数组去重



##### 4. 数组方法的实现原理

+ **filter**

```js
// apply
Array.prototype._filter = function(fn, thisArg) {
    if (fn.constructor !== Function) {
        throw new Error(fn +'is not a function')
    }
    let newArr = []
    for(let i = 0; i < this.length; i++) {
        if (fn.apply(thisArg, [this[i], i, this])) {
          newArr.push(this[i])
        }
    }
    return newArr
}

// call
Array.prototype._filter = function (fn, thisArg) {
    if (fn.constructor !== Function) {
       throw new Error(fn +'is not a function')
    }
    let newArr = []
    for (let i = 0; i < this.length; i++) {
        if (fn.call(thisArg, this[i], i, this)) {
            newArr.push(this[i])
        }
    }
    
    return newArr
}

const arr = [1, 2, 3, 4, 5, 6, 7]
arr._filter(item => item > 5)  // [6, 7]
```

+ **map**

```js
// apply
Array.prototype._map = function (fn, thisArg) {
    if (fn.constructor !== Function) {
       throw new Error(fn +'is not a function')
    }
    let newArr = []
    for (let i = 0; i < this.length; i++) {
        newArr.push(fn.apply(thisArg, [this[i], i, this]))
    }
    
    return newArr
}

const arr = [1, 2, 3, 4]
arr._map((item, index) => {
    console.log(index)	// 0 1 2 3
    return item * item	// [1, 4, 9, 16]
})
```

+ **forEach**

```js
Array.prototype._forEach = function (fn, thisArg) {
    if (fn.constructor !== Function) {
      throw new Error(fn +'is not a function')
    }
    for(let i = 0; i < this.length; i++) {
        fn.apply(thisArg, [this[i], i, this])
    }
}

arr._forEach(item => {
    a = item
    console.log(item)
})
// 1 2 3 4
a
// 4
```

+ **find**

```js
Array.prototype._find = function(fn, thisArg) {
    if(fn.constructor !== Function) {
        throw new Error(fn + 'is not a function')
    }
    for (let i = 0; i < this.length; i++) {
        if(fn.call(thisArg, this[i], i, this)) return this[i]
    }
}
const arr = [1, 2, 3, 4, 5, 6]
const arr1 = arr._find(item => return item > 2)
arr1	// 3
```



+ **reduce**

`reduce`为数组中的每一个元素依次执行`callback`函数，不包括数组中被删除或callback的参数：

- `accumulator 累计器`
- `currentValue 当前值`
- `currentIndex 当前索引`
- `array 数组`

**语法**：arr.reduce(callback, initValue)    回调函数和默认值两个参数，默认值可以省略。

1. 
2. 如果**没有初始值**，pre将使用数组中的第一个元素
3. 在**没有初始值**的**空数组**上调用reduce将报错。
4. 在**没有初始值**的**仅有一个元素的**数组上使用reduce，那么callback不会执行，此唯一值将被返回。

```js
[1, 2, 3, 4].reduce((pre, next) => pre + next)	// 10
[].reduce((pre, next) => pre + next, 2)	// 2
[].reduce((pre, next) => pre + next)	//Uncaught TypeError: Reduce of empty array with no initial value
```

```js
Array.prototype._reduce = function(fn, initValue) {
    let acc = initValue
    if (acc) {
        for(let i =0; i < this.length; i++) {
            acc = fn(acc, this[i])
        }
    } else {
        for(let i = 1; i < this.length; i++) {
            if(i === 0) {
                acc = fn(this[0], this[1])
            } else {
                acc = fn(acc, this[i])
            }
        }
    }
    return acc 
}

const arr = [1, 2, 3, 4, 5]
arr._reduce((pre, next) => pre + next, 100)  // 115
```



##### 5. 数组扁平化

**flat(Infinity)**

```js
const arr  = [1, 2, [3, [4, 4, 5]]]
arr.flat(Infinity)	// [1, 2, 3, 4, 4, 5]
```

**JSON.stringfy + 正则 + JSON.parse**

```js
function flatter(arr) {
    let str = JSON.stringify(arr).replace(/[\[|\]]/g, '')
    str = `[${str}]`
    return JSON.parse(str)
}
const arr = [1, [2, 3, [4, 5, [6]]]]
flatter(arr)	// [1, 2, 3, 4, 5, 6]
```

**递归**

```js
function flatter(arr) {
    let newArr = []
    arr.forEach(item => {
        if(Array.isArray(item)) {
            newArr = newArr.concat(flatter(item))
        }
        else {
            newArr.push(item)
        }
    })
    return newArr
}
const arr = [1, 2, 3, [3, 4, 5, [6, 7]]]
flatter(arr)	// [1, 2, 3, 3, 4, 5, 6, 7]
```

**Reduce + 递归**

```js
function flatter(arr) {
    return arr.reduce((prev, next) => {
        return prev.concat(Array.isArray(next) ? flatter(next) : next)
    }, [])
}

const arr = [1, 2, 3, [4, 5, [6, 7, 8]]]
flatter(arr)	// [1, 2, 3, 4, 5, 6, 7, 8]
```

**[].concat(...arr)**

```js
const arr = [1, 2, [3 ,4, [5, 6]]]
// 该操作可以拍平一层
[].concat(...arr)	// [1, 2, 3, 4, Array(2)]   [1, 2, 3, 4, [5, 6]]



```



#### 判读JS数据类型的方法

总结： 简单来说，我们使用 `typeof` 来判断基本数据类型是 ok 的，不过需要注意当用 `typeof` 来判断 `null` 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 `instanceof`，但是 `instanceof` 也可能判断不准确，比如一个数组，他可以被 `instanceof` 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 `Object.prototype.toString.call` 方法

##### 1、typeof操作符

```js
typeof 2 // "number"
typeof 'cpp' // "string"
typeof null // "object"
typeof undefined // "undefined"
typeof [] // "object"
typeof {} // "object"
typeof true // "boolean"
typeof function(){} // "function"
typeof Symbol()  // "symbol"
```

+ 对于基本类型，除null外，均可以返回正确的结果
+ 对于引用类型，除function以外，一律返回object类型
+ 对于null，返回object类型
+ 对于function， 返回function类型

##### 2. Object.prototype.toString

可以用这个方法来对类型进行比较准确的判断。

```js
Object.prototype.toString.call(1) // "[object Number]"

Object.prototype.toString.call('hi') // "[object String]"

Object.prototype.toString.call({a:'hi'}) // "[object Object]"

Object.prototype.toString.call([1,'a']) // "[object Array]"

Object.prototype.toString.call(true) // "[object Boolean]"

Object.prototype.toString.call(() => {}) // "[object Function]"

Object.prototype.toString.call(null) // "[object Null]"

Object.prototype.toString.call(undefined) // "[object Undefined]"

Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"

```



##### 2、 instanceof

instanceof主要的作用就是判断一个实例是否属于某种类型。

instanceof也可以判断一个实例是否是其父类型或者祖先类型给的实例。

**原理**：

instanceof的实现原理就是只要右边变量的`prototype`在左边变量的原型链上即可。因此，`instanceof`在查找的过程中会遍历左边变量的原型链，直到右边变量的`prototype`，如果查找失败，则返回false

#### 基本包装类

当基本数据类型调用方法时，比如:

```js
const number = 13.141314
// 基本数据类型本来是没有实例方法的
// 当调用toFixed()的时候，它会在背后创建一个基本包装类
// let number = new Number()
// number实例就可以调用Number构造函数上的方法
// number = null
// 执行完这行代码后，就销毁

number.toFixed(2)	//  "13.14"
```

```js
let str = "hello world";
str.length;              // 11
str.toUpperCase();       // HELLO WORLD
```

我们看到的代码是上面的样子，其实后台会自动完成下列的处理：

- 执行到第二行时：
  - 创建 String 类型的一个实例；
  - 在实例上调用指定的**属性**；
  - 销毁这个实例；
- 执行到第三行时：
  - 创建 String 类型的一个实例；
  - 在实例上调用指定的**方法**；
  - 销毁这个实例；

可以将上面的步骤想象成下列 ECMAScript 代码：

```js
// 执行到第二行时
let str = new String("hello world");
str.length;
str = null;

// 执行到第三行时
let str = new String("hello world");
str.toUpperCase();
str = null;
```

#### 原型和继承

##### 原型

比如举个例子：

1. 当我们声明一个`Animal`的构造函数，此时它就会创建一个`Animal.prototype`的原型对象。
2. `Animal.prototype`指向`Object.prototype`
3. 然后我们通过`new Animal()`生成一个`Animal`的实例。
4. 实例的`__proto__`属性指向了`Animal.prototype`
5. 当我们在实例中查找一个属性或者方法的时候，会先看实例自己有没有这个属性和方法，没有的话会去`Animal.prototype`里面找，还是没有就会去`Object.prototype`里面找。

#####  继承： 

1. 目标：子类具有父类的方法和属性

实例中找不到属性和方法—去原型找

+ 打通原型链

Fighter.prototype = bew Plane('blue')

**缺点：**

+ 借用构造函数继承

借用构造函数继承可以传递参数，可以在调用`.call`函数的时候将参数传给父类。比如：

这是在子类Fighter构造函数中将`color`属性传给父类构造函数。

```js
Plane.call(this, color)
```

+ 组合继承

打通原型链+借用构造函数继承

```js
function Person(name) {
    this.name = name;
}
Person.prototype.sayHello = function() {
    console.log('Hi! My name is ' + this.name + '.');
}

function Student(name, grade) {
    // 借用构造函数在实例中继承属性
    Person.call(this, name);  // 第二次调用
    this.grade = grade;
}
// 原型链的方式继承原型方法
Student.prototype = new Person();	// 第一次调用
Student.prototype.sayGrade = function() {
    console.log('I am Grade ' + this.grade + '.');
}
```



缺点：重复调用

​			属性冗余

+ 最佳继承



#### 闭包和this

+ **闭包是指有权访问另一个函数作用域中变量的函数**
+ 闭包是一个带有数据的函数

+ 创建私有方法的一种手段



#### 函数的属性

+ name

+ length
  
  + arguments.length
  
+ **prototype**：

  1.  原型是函数的一个属性，是一个对象

  2. 如果函数作为构造函数使用，那么这个构造函数的所有实例，都共享这个原型对象

  + constructor
  + 读写
  + isPrototypeOf

当我们声明了一个Person函数后，就会生成Person.prototype对象

通过构造函数生成的对象，会共享这个构造函数的原型

in操作符，只要对象里面有这个属性，不管在原型还是实例上都会返回true

hasOwnProperty判断一个属性在不在实例上

#### 构造函数

**构造函数的不足之处**：功能相同的函数，重复声明消耗空间。

#### 1. new操作符

1. 首先创建一个空对象

2. 将这个空对象的`__proto__`属性指向构造函数的原型属性，从而继承原型上的属性、方法

```js
const obj = {
    __proto__: Fn.prototype
}
```

3. 把上面创建的空对象赋值给构造函数内部的this，用构造函数内部的方法修改空对象，以获取私有属性

4. 如果构造函数返回一个非基本类型的值a，则返回这个值a，否则返回上面创建的对象obj

```js
function A() {
    return [123]
}
new A()  // [123]
```

**实现一个new**：Fn为构造函数

```js
function myNew(Fn, ...arg) {
    const obj = Object.create(Fn.prototype)
    const ret = Fn.apply(obj, arg)
    return ret instanceof Object ? ret : obj
}
```

const a = Object.create(b)

创建了一个新对象a，其中a的`__proto__`指向了传入的对象

#### 2. instanceof

**作用**：

1. 用于判断某个实例是否属于某构造函数
2. 在继承关系中用来判断一个实例是否属于它的父类或者祖先类型的实例

[对象]instanceof[构造函数]

`Object.getPrototypeOf()`方法返回指定对象的原型(内部`[[Prototype]]`)

```js
const prototype1 = {};
const object1 = Object.create(prototype1);

Object.getPrototypeOf(object1) === prototype1	// true
object1.__proto__ === prototype1	// true
```

`Obcject.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`

**底层原理**

```js
function myInstanceof(L, R) {
    if(typeof L !== 'object' || L === null) return false
    //  let Lproto = L.__proto__  //  代码里面最好不要写__proto__
    let Lproto = Object.getPrototypeOf(L)
    let RProto = R.prototype
	while(true) {
		if (Lproto === null) return false
		if (Lproto === RProto) return true
        Lproto = Object.getPrototypeOf(Lproto)
	}
}

function Person(name) {
    this.name = name
}
const p = new Person('cpp')
myInstanceof(p, Person)	  // true

const arr = [2]
myInstanceof(arr, Array)	// true

myInstanceof(arr, Object)	// true
```

只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false

**代码解释**

1. L代表对象实例，R表示构造函数或者父类型实例
2. 取R的显式原型(`prototype`)，`Rproto = R.prototype`；取L的隐式原型(`__proto__`)，`Lproto = L.__proto__`
3. 循环遍历，进行判断`Rproto`和`Lproto`是否相等，相等返回true，不相等继续查找实例L的原型链。

**测试**：

```js
function Person(name, age) {
    this.name = name 
    this.age = age
}
const p = new Person('cpp', 2)
myInstanceof(p, Person)  // true
```



实现的new和instanceof整体测评

```js
function myInstanceof(L, R) {    
    if(typeof L !== 'object' || L === null) return false
    const Rproto = R.prototype
    const Lproto = L.__proto__ 
    while(true) {
        if (Lproto === null) return false
        if (Lproto === Rproto) return true
        Lproto = Lproto.__proto__
    }
}

function _new(fn, ...arg) {
    const obj = Object.create(fn.prototype);
    const ret = fn.apply(obj, arg);
    return myInstanceof(ret, Object) ? ret : obj;
}

function Person(name, age) {
    this.name = name 
    this.age = age
}

const p = _new(Person, 'cpp', 2)

p	// Person {name: "cpp", age: 2}
```

#### 浅拷贝 + 深拷贝

##### 一、数据类型

基本数据类型的特点：直接存储在栈(stack)中的数据

引用数据类型的特点：栈里面存的是引用类型的地址，数据存储在堆内存中，从栈中获取了该对象的地址引用(或地址指针)，然后从内存中取得我们需要的数据。

##### 二、浅拷贝与深拷贝

深拷贝与浅拷贝是只针对Object和Array这样的引用数据类型的。

浅拷贝只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

**1. 浅拷贝的实现方式**

```js
// Object.assign
const source = {
    lg: {
        name: 'cpp',
        age: 2
    },
    love: 'game'
}
const target = Object.assign({}, source)
target	//  lg: {name: "cpp", age: 2}
		//  love: "game

// 修改了target的对象属性的属性值后
target.lg.name = 'cjz'
target	// lg: {name: "cjz", age: 2}
		// love: "game"
source	// lg: {name: "cjz", age: 2}
		// love: "game"


// 当object只有一层的时候是深拷贝
const source = {
    name: 'cpp',
    age: 2
}
const target = Object.assign({}, source)
target	// {name: "cpp", age: 2}

// 修改target的属性后
target.name = 'cjz'
target	// {name: "cjz", age: 2}

// 扩展运算符
const source = {
    lg: {
        name: 'cpp',
        age: 2
    },
    love: 'game'
}
const target = { ...source }

// slice和concat不修改原数组，只会返回一个浅复制了原数组的元素的一个新数组。
// slice
const source = [1, 2, 3]
const target = source.slice()zhie

const source = [1, 2, 3, { name: 'cpp', age: 2 }]
const target = source.slice()

// 修改引用类型一项
target[3].name = 'cjz'
target	// [1, 2, 3, { name: 'cjz', age: 2 }]
source  // [1, 2, 3, { name: 'cjz', age: 2 }]


// concat
const source = [1, 2, 3, { name: 'cpp', age: 2 }]
const target = source.concat()
target  // [1, 2, 3, { name: 'cpp', age: 2 }]
target[3].name = 'cjz'
target	// [1, 2, 3, { name: 'cjz', age: 2 }]
source	// [1, 2, 3, { name: 'cjz', age: 2 }]

```

**2. 深拷贝的实现方式**

+ `JSON.parse(JSON.stringify())`:这种方法虽然能实现深拷贝，但不能处理函数，只能用于对象内部没有函数方法。
  + 原理：用JSON.stringify将对象转换成JSON字符串，再用JSON.parse()把字符串解析成对象，新的对象产生了，而且会开辟新的栈，实现深拷贝。

```js
// JSON.parse(JSON.stringify())
// 只能用于对象内部没有函数方法时
const source = [1, 2, 3, { name: 'cpp', age: 2 }]
const target = JSON.parse(JSON.stringify(source))
target[3].name = 'cjz'
target	// [1, 2, 3, { name: 'cjz', age: 2 }]
source	// [1, 2, 3, { name: 'cpp', age: 2 }]



// 2. 递归，简陋版
function deepClone(source) {
    let target = null
    if (typeof source === 'object' && source !== null) {
        target = Array.isArray(source) ? [] : {}
        for(let [key, value] of Object.entries(source)) {
            target[key] = deepClone(value)
        }
    }  else {
        target = source
    }
    return target
}
const source = {
    name: 'cpp',
    age: 2,
    child: {
       id: 1
    },
    arr: [1, 2, 3],
    sayName: function() {
        console.log(name)
    }
}
const target = deepClone(source)
target
//const source = {
//    name: 'cpp',
//    age: 2,
//    child: {
//    id: 1
//    },
//    arr: [1, 2, 3],
//    sayName: function() {
//        console.log(name)
//    }
//}

// 修改引用类型后， 不会影响原对象内部
target.child.id = 2
target
//const source = {
//    name: 'cpp',
//    age: 2,
//    child: {
//      id: 2
//    },
//    arr: [1, 2, 3],
//    sayName: function() {
//        console.log(name)
//    }
//}


source
//const source = {
//    name: 'cpp',
//    age: 2,
//    child: {
//    id: 1
//    },
//    arr: [1, 2, 3],
//    sayName: function() {
//        console.log(name)
//    }
//}

// 上面这样无法解决循环引用的问题
// 例如
let obj = {}
obj.a = obj
deepClone()	// Uncaught RangeError: Maximum call stack size exceeded
// 会一直递归调用deepClone,造成函数栈溢出


// 3. 复杂版
// 使用WeakMap解决循环引用的问题
// 
function deepClone(source, hash = new WeakMap) {
    let target = null
    if (hash.has(source)) {
        return hash.get(source)
    }
    if (typeof source === 'object' && source !== null) {
        target = Array.isArray(source) ? [] : {}
        hash.set(source, target)
        for (let [key, value] of Object.entries(source)) {
            target[key] = deepClone(value, hash)
        } 
    } else {
        target = source
    }
    return target
}
const obj = {}
undefined
obj.a = obj
obj	// {a:{a:{a:{...}}} }

// 拷贝成功
deepClone(obj, hasn = new WeakMap)	// // {a:{a:{a:{...}}} }
```



##### 扩展

WeakMap

Map

#### 事件循环机制

永远都是**栈里的代码先行执行**，再从队列中依次读事件，加入栈中执行

栈里面的都走完之后，就会依次读取任务队列，将队列里面中的事件放到执行栈中以此执行，这个时候栈中又出现了事件，这个事件又去调用了WebAPIs里的异步方法，那这些异步方法会在被调用的时候放在队列里，然后这个主线程执行完后又将从任务队列中依次读取事件，这个过程是循环不断的。

**概念**：**微任务和宏任务都是属于队列，而不是放在栈中。**

##### 宏任务（task）

浏览器为了使得JS内部宏任务(task)与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染(task —>渲染—>task—>.....)鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTML。但是，**setTimeout不一样，setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务。**

##### 微任务（Microtasks）

微任务通常来说就是需要在当前task执行结束后立即执行的任务 比如对一系列动作做出反馈，或者是需要异步的执行任务而又不需要分配一个新的task，这样便可以减小一点性能的开销。只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。

微任务包括了mutation observe的回调，还有接下来**promise的回调。**

一旦一个promise有了结果，或者早已有了结果（有了结果是指这个promsie到了fufilled的rejected状态），它就会为它的回调产生一个微任务，这就证了回调异步的执行即使这个promise早已有了结果。

#### 函数

##### 1. 函数防抖

**定义**

防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次。

指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又出发了该事件，则会重新开始算规定时间。

**问题**：为什么要把事件触发调用的函数放在闭包里面。

函数防抖函数节流要用闭包的原因：多个函数的调用都需要有以公共的变量来控制（被return的函数被调用了很多次）

```js
const debounceInput = document.querySelector('.debounce-input')
    debounceInput.addEventListener('input', debounce(fn, 500))
function debounce(fn, delay) {
  let timer = null
  return function() {
    console.log(this)
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      fn.call(this)
    }, delay);
  }
}
function fn() {
  console.log('添加函数防抖')
}
```

##### 2. 函数节流

**定义**：当持续触发事件时，在规定时间内之恩那个调用一次回调函数。如果在规定时间内又触发了该事件，则什么也不做，也不会重置定时器。

**与防抖比较**：防抖是将多次执行变为最后依次执行，节流是将多次执行变为在规定时间内只执行一次，一般**不会重置定时器**

**应用场景**

**问题**：`clearTimeout(timer)`和`timer=null`有什么区别。

```js
// window.addEventListener('scroll', () => {
//   console.log('未对函数节流')
// })
window.addEventListener('scroll', throttle(fn, 1000))
function throttle(fn, delay) {
  let timer = null
  return function() {
    if (timer) return
    timer = setTimeout(() => {
      console.log(this)
      fn.call(this)
      timer = null
    }, delay);
  }
}
function fn () {
  console.log('对函数节流')
}
```

##### 3. 实现bind

```js
Function.prototype._bind = function(thisArg, ...argArray) {
    //  bind方法返回一个有固定this的新函数，用箭头函数是因为想要实例作为this
    return (...newArgArray) => {  
        // newArgArray是函数的传参
        // argArray是bind里面传的参数
        return this.call(thisArg, ...argArray, ...newArgArray)    // 取值会按顺序，先取argArray
    }
}

// 测试
function Test(a, b, c) {
    return a + b + c 
}
const obj = {}
const Test2 = Test.bind(obj, 10, 20)
Test2(3)	// 33

Test2 
// ƒ Test(a, b, c) {
//    return a + b + c 
// }
```

##### 4. 实现call

call方法的实现主要有以下三步，比如`fn.call(obj, a, b)`

1. 把构造函数fn的上下文指向obj
2. 形参a, b等是以逗号分隔传进去
3. 执行函数fn，并返回结果

```js
Function.prototype.myCall = function(thisArg, ...args) {
    context = thisArg || window
    context.fn = this	//  此处this即为需要改变this的函数，把该函数绑定在上下文环境的一个fn属性上作为方法调用。
    let result = context.fn(...args)
    delete context.fn
    return result 
}
```

##### 5. 实现apply函数

```js
Function.prototype.myApply = function(thisArg, args) {
    context = thisArg || window
    context.fn = this
    let result = context.fn(...args)  // args为数组，这里用扩展运算符解开
    delete context.fn
    return result 
}
```

#### JSON parse + JSON stringify

```js
// 如果里面有函数方法。函数方法不会解析
const source = {
    name: 'cpp',
    age: 2,
    sayName: function() {
        console.log(name)
    }
}
JSON.stringify(source)	// "{"name":"cpp","age":2}"
```

#### Set、Map

##### 1. Set

**概念**： 本身是一个构造函数，用来生成Set数据结构(它类似于数组，但是成员的值都是唯一的，没有重复的值)

+ 向Set加入值的时候，不会发生类型转换，所以 5和'5'是两个不同的值。它类似于精确相等运算符(===)，主要的区别是向 Set 加入值时认为`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。
+ 另外，两个对象总是不相等的
+ `Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化

```js
const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4

// 数组去重
const arr = [1, 2, 2, 3, 4, 4, 5]
const arr1 = [...new Set(arr)]
arr1  //  [1, 2, 3, 4, 5]

// 去除字符串里面的重复字符
const str = [...new Set('aabbccaa')].join('')
str  // "abc“

// 两个对象总是不相等的
let set = new Set()
set.add({})
set.size	//  1
set.add({})
set.size	// 2
// 上面代码中，由于连个空对象不相等，所以它们被视为两个值。

// Arra.from()方法可以将Set解构转为数组
const items = new Set([1, 2, 3, 4, 5])
const arr = Array.from(items)
arr  //  [1, 2, 3, 4, 5]
// 这就提供了去除数组成员的另一种方法
const arr = Array.from(new Set([1, 2, 2, 3, 4]))
arr // [1, 2, 3, 4]
```

**Set实例的属性和方法**

Set结构的实例有以下属性。

+ `Set.prototype.constructor`：构造函数， 默认就是Set函数
+ `Set.prototype.size`: 返回Set实例的成员总数。

Set 实例的方法分为两大类：**操作方法**（用于操作数据）和**遍历方法**（用于遍历成员）。下面先介绍**四个操作方法。**

- `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身。
- `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `Set.prototype.clear()`：清除所有成员，没有返回值。

**遍历方法**

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
- `Set.prototype.entries()`：返回键值对的遍历器
- `Set.prototype.forEach()`：使用回调函数遍历每个成员

由于Set解构没有键名，只有键值(或者说键名和键值)，所以`keys`和`values`的方法的行为完全一致。

**Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。**

```javascript
Set.prototype[Symbol.iterator] === Set.prototype.values
```

```javascript
let set = new Set(['red', 'green', 'blue']);

for (let x of set) {
  console.log(x);
}
// red
// green
// blue
```

**遍历的应用**

扩展运算符(`...`)内部使用`for...of`循环，所以可以用Set结构

```javascript
let set = new Set(['red', 'green', 'blue']);
let arr = [...set];
// ['red', 'green', 'blue']
```

##### 2. WeakSet

WeakSet与Set结构类似，也是不重复的值的集合，但是，它与Set有两个区别。

首先，WeakSet的成员只能是对象，而不能是其他类型的值。

WeakSet不可遍历。

##### 3. Map

作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。

```js
// Map的参数为可遍历的，向Map结构添加成员的时候可以用map.set(o, 'la')
// Map也可以接受数组作为参数，会遍历Map的参数，
const map = new Map([
    ['name', 'cpp'],
    ['age', 2]
])
```

Map构造函数接受数组作为参数，实际上执行的是下面的算法

```js
const items = [['name', 'cpp'], ['age', 2]]
const map = new Map()
items.forEach(([key, value]) => map.set(key, value))
map	// {"name" => "cpp", "age" => 2}
[[Entries]]
//  0: {"name" => "cpp"}
//  1: {"age" => 2}
//  size: 2
```

不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素的数组的数据结构，都可以当作Map构造函数的参数。这就是说

Set和Map都可以用来生成新的Map

如果对同一个键多次赋值，后面的值将覆盖前面的值

```js
const map = new Map()
map.set(1, 'aaa')
   .set(1, 'bbb')
map  // {1 => "bbb"}
```

如果读取一个未知的键，则返回`undefined`。

```js
new Map().get('aaaa')
// undefined
```

只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

```javascript
const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
```

```js
const a = ['a']
const map = new Map();
map.set(a, 555)
map.get(a)	// 555
```

由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。

**Map实例的属性和操作方法**

**属性**

1. size属性

**操作方法**

1. `Map.prototype.set(key, value)`

set方法返回的是当前的Map对象，因此可以采用链式写法

```js
const map = new Map()
    .set(1, 'a')
    .set(2, 'b')
    .set(3, 'c')
map  // {1 => "a", 2 => "b", 3 => "c"}
```

3. `Map.prototype.get(key)`： `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。
4. `Map.prototype.has(key)`: 返回一个布尔值，表示某个键是否在当前Map对象之中。

5. `Map.prototype.delete(key)`
6. `Map.prototype.clear()`

**遍历方法**

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `Map.prototype.keys()`：返回键名的遍历器。
- `Map.prototype.values()`：返回键值的遍历器。
- `Map.prototype.entries()`：返回所有成员的遍历器。
- `Map.prototype.forEach()`：遍历 Map 的所有成员

**Map 结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法**

```js
const map = new Map([['name', 'cpp'], ['age', 2]])
for (let [key, value] of map) {
    console.log(key, value)
}
//  name cpp
//  age 2
```

Map结构转为数组结构比较快速的方法是使用扩展运算符(`...`)

```js
const map = new Map([['name', 'cpp'], ['age', 2]])
[...map.keys()]	 // ["name", "age"]
[...map.values()]	//  ["cpp", 2]
[...map.entries()]	//  ["name", "cpp"]
					//	["age", 2]

[...map]	//  ["name", "cpp"]
			//	["age", 2]
```

**结合数组的map方法、filter方法，**可以实现Map的遍历和过滤

```js
const map0 = new Map()
    .set(1, 'a')
    .set(2, 'b')
    .set(3, 'c')
const map1 = new Map(
    [...map0].filter(([k, v]) => k < 3)
)
map1	// {1 => "a", 2 => "b"}
const map2 = new Map(
    [...map0].map(([k, v]) => [k*2, '_' + v])
)
map2	// {2 => "_a", 4 => "_b", 6 => "_c"}
```

forEach

```js

```

**与其他数据结构的互相转换**

**1. Map转为数组**：使用扩展运算符

**2. 数组转为Map**：将数组传入Map构造函数，就可以转为Map

**3. Map转为对象**：如果所有Map的键都是字符串，它可以无损地转为对象。

​								如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名

**4. 对象转为Map**：对象转为Map可以通过`Object.entries()`

```js
const obj = {name: 'cpp', age: 2}
const map = new Map(Object.entries(obj))
map  // {"name" => "cpp", "age" => 2}
```

**5. Map转为JSON**:

+ 一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON
+ 另一种情况是，Map的键名有非字符串，这是可以选择转为数组JSON



##### 5. WeakMap

WeakMap结构与Map结构类似，也是用于生成键值对的集合

**WeakMap与Map的区别有两点。**

+ **首先，WeakMap只接受对象作为键名(null除外)，不接受其他类型的值作为键名**

+ **其次，WeakMap的键名所指向的对象，不计入垃圾回收机制**

如果你要想往对象上添加数据，又不想干扰垃圾回收机制，就可以使用WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

```javascript
const wm = new WeakMap();
let key = {};
let obj = {foo: 1};

wm.set(key, obj);
obj = null;
wm.get(key)
// Object {foo: 1}
```

上面代码中，键值`obj`是正常引用。所以，即使在 WeakMap 外部消除了`obj`的引用，WeakMap 内部的引用依然存在。

**WeakMap与Map在API上的区别主要有两个**

+ **一是没有遍历操作（即没有keys(),values()和entries()方法)，也没有size属性。**
+ **二是无法清空，即不支持clear方法**

**因此，WeakMap只有四个方法可用：get(),set(),has(),delete()**

**WeakMap的用途**

1. Dom节点作为键名
2. WeakMap的另一个用处是部署私有属性
